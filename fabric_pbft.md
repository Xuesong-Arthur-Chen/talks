基本上pbft是比较流行的用在联盟链中达成共识的算法（状态机共识），它的主要特点是能容忍一定数量的恶意或者有缺陷的节点，在通常情况下对性能影响不大。
它的基本思想：每个节点有一对公钥和私钥，当节点收到客户端发来的一笔交易，它会验证交易的合法性然后用它的私钥签名，当有足够多的节点（例如3分之2）签名后，
这笔交易就被整个网络认为是合法交易。

在hyperledger fabric 0.6中，通常的基本流程如下：
所有的验证节点都互相连接，客户端可以向验证节点提交交易,某个节点被选为领导节点：
1. 领导节点把接收到的交易排序，然后把排序好的交易队列广播给其他节点
2. 当一个节点收到领导节点发来的排好序的交易队列后，它就一笔一笔的执行每笔交易
3. 当队列中的所有交易都被执行后，节点会计算交易队列形成的新块的哈希值，然后签名
4. 每个节点把新块的哈希值和签名广播给其他节点
5. 当每个节点接收到了足够多的相同的新块的哈希值和合法的签名后，新块的共识就达成了
6. 领导节点或者所有节点向客户端发送成功通知

在hyperledger fabric 1.0中，执行交易和签名，交易排序打包，验证新块的任务被分离
1. 客户端向所有背书节点提交交易
2. 背书节点执行交易然后签名，发送结果给客户端
3. 客户端收集到足够多的签名背书后，把成功背书发给排序服务
4. 排序服务有3个选项：单个进程排序；kafka排序；简单bft排序
5. 排序服务把新块（排好序的交易队列）发给所有节点
6. 所有节点验证新块里的每一笔交易的背书签名和并发依赖，都通过了就认为是合法交易了
7. 某个节点把结果发送给客户端

以上都是在通常情况下的流程。如果在异常情况下，如某些节点出错或被恶意代码控制，整个系统的性能会下降，需要考虑异常处理，例如消息丢失，乱序，
节点掉线后恢复到最新状态，领导节点出错等等。具体的异常处理可参看论文”Practical Byzantine Fault Tolerance”中的4.3 garbage collection 
和4.4 view changes
